// Generated by CoffeeScript 1.10.0

/**
 * 开发模式下的监控模块
 * @date 2015年11月23日17:37:08
 * @author pjg <iampjg@gmail.com>
 * @link http://pjg.pw
 * @version $Id$
 */
var CssCtl, FontsCtl, HtmlCtl, ImgCtl, JSHINT, JsCtl, Tools, TplCtl, Utils, Watch, _, color, cssCtl, fontsCtl, fs, gutil, htmlCtl, imgCtl, jsCtl, jshint, opts, path, spCtl, spOpts, sprite, tplCtl, watcher,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require("fs");

path = require("path");

_ = require("lodash");

gutil = require("gulp-util");

color = gutil.colors;

Watch = require("gulp-watch");

sprite = require('../spCtl');

jshint = require("jshint");

JSHINT = jshint.JSHINT;

Tools = require("../utils");

CssCtl = require("../cssCtl");

JsCtl = require("../jsCtl");

TplCtl = require("../tplCtl");

HtmlCtl = require("../htmlCtl");

FontsCtl = require("../fontsCtl");

ImgCtl = require("../imgCtl");

opts = global.Cache["gOpts"];

spOpts = {
  srcPath: opts.srcPath,
  imgOutPath: opts.debugPath + 'img/sprite'
};

spCtl = new sprite(spOpts);

cssCtl = new CssCtl(opts);

jsCtl = new JsCtl(opts);

tplCtl = new TplCtl(opts);

htmlCtl = new HtmlCtl(opts);

fontsCtl = new FontsCtl(opts);

imgCtl = new ImgCtl(opts);

Utils = {
  getCache: function() {
    var _cache, cacheFile, e, error1, maps;
    _cache = {};
    maps = ["img", "css", "js", "jsHash", "jsSource", "spMap"];
    if (!_.has(global.Cache, "cssMap") && !_.has(global.Cache, "jsMap")) {
      cacheFile = opts.mapPath + "cache.json";
      if (fs.existsSync(cacheFile)) {
        try {
          _cache = JSON.parse(fs.readFileSync(cacheFile), "utf8");
          return global.Cache = _.assign(global.Cache, _cache);
        } catch (error1) {
          e = error1;
          return maps.forEach(function(val, key) {
            return Tools.getMap(val);
          });
        }
      } else {
        return maps.forEach(function(val, key) {
          return Tools.getMap(val);
        });
      }
    }
  },
  jsHint: function(file) {
    var _source, e, error1;
    try {
      gutil.log(color.cyan("jshint.JS语法检测开始-->"));
      _source = fs.readFileSync(file, "utf8");
      !!JSHINT(_source);
      JSHINT.errors.filter(function(error) {
        if (error) {
          gutil.log(color.magenta(file.replace(opts.root, '')), "error in line -->", color.magenta(error.line));
          return gutil.log(color.yellow(error.reason));
        }
      });
      return gutil.log(color.cyan("jshint.JS语法检测结束"));
    } catch (error1) {
      e = error1;
      return console.log(e);
    }
  },
  getType: function(dir) {
    var _path;
    _path = dir.replace(/\\/g, "/").replace(/\/\//g, "/");
    return (_path.split(opts.srcPath)[1]).split("/")[0];
  },
  less: function(cb) {
    var _cb;
    _cb = cb || function() {};
    return cssCtl.less2css(_cb, !0);
  },
  sprite: function(file, cb) {
    var _folder;
    _folder = (file.split('sprite/')[1]).split('/')[0];
    return spCtl.outputOne(_folder, cb);
  },
  tpl: function(file, cb) {
    var _folder;
    _folder = (file.split('tpl/')[1]).split('/')[0];
    return tplCtl.convertHtmlToJs(_folder, cb);
  },
  html: function(cb) {
    return htmlCtl.init(cb);
  },
  js: function(file, cb) {
    if (file.indexOf('_tpl/') === -1) {
      this.jsHint(file);
    }
    return jsCtl.toAmd(file, cb);
  },
  msg: function(fileName) {
    return gutil.log("'" + color.cyan(fileName) + "'", "build success.");
  },
  fonts: function(cb) {
    return fontsCtl.init(cb);
  },
  img: function(cb) {
    return imgCtl.init(cb);
  }
};


/*
 * 开发的监控API
 */

watcher = function(cb) {
  var _filePaths, _files, _list, _this;
  _this = this;
  _list = [];
  _files = [opts.srcPath + "/less/**/*.less", opts.srcPath + "/sprite/**/*.png", opts.srcPath + "/html/**/*.html", opts.srcPath + "/js/**/*.js", opts.srcPath + "/tpl/**/*.html", opts.srcPath + "/img/*.{gif,jpg,png,svg,ico}", opts.srcPath + "/img/**/*.{gif,jpg,png,svg,ico}", "!.DS_Store"];
  _filePaths = [];
  opts.fontExt.forEach(function(value, index) {
    return _filePaths.push(opts.srcPath + "/fonts/**/*." + value);
  });
  _files = _files.concat(_filePaths);
  Utils.getCache();
  return Watch(_files, function(file) {
    var _event, _filePath, _type, err, error1, watch_timer;
    try {
      _event = file.event;
      if (_event !== "undefined") {
        _filePath = file.path.replace(/\\/g, "/");
        if (indexOf.call(_list, _filePath) < 0) {
          _list.push(_filePath);
          gutil.log("'" + color.cyan(file.relative) + "'", "was " + _event);
          _type = Utils.getType(_filePath);
          switch (_type) {
            case "sprite":
              Utils.sprite(_filePath, function() {
                return Utils.msg(file.relative);
              });
              break;
            case "less":
              Utils.less(function() {
                return Utils.msg("CSS");
              });
              break;
            case "html":
              Utils.html(function() {
                return Utils.msg("HTML template");
              });
              break;
            case "js":
              Utils.js(_filePath, function() {
                return Utils.msg(file.relative);
              });
              break;
            case "tpl":
              Utils.tpl(_filePath, function() {
                return Utils.msg(file.relative);
              });
              break;
            case "img":
              Utils.img(function() {
                return Utils.msg('img copy');
              });
              break;
            case "fonts":
              Utils.fonts(function() {
                return Utils.msg('font copy');
              });
          }
        }
      }
      if (watch_timer) {
        clearTimeout(watch_timer);
      }
      return watch_timer = setTimeout(function() {
        return _list = [];
      }, 3000);
    } catch (error1) {
      err = error1;
      return console.log(err);
    }
  });
};

module.exports = watcher;
