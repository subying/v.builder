// Generated by CoffeeScript 1.10.0

/**
 * 雪碧图构建基类
 * @author pangjg
 * @date 2015-11-26 22:09:36
 */
var SpBase, SpInit, Utils, _, color, fs, gutil, path,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

path = require('path');

_ = require('lodash');

gutil = require('gulp-util');

color = gutil.colors;

Utils = require('../utils');


/* 单个雪碧图的状态检查类库 */

SpInit = (function() {
  function SpInit(opts) {
    this.opts = opts;
    this.srcPath = this.opts.srcPath + 'sprite';
    this.imgOutPath = this.opts.debugPath + 'img/sprite';
    this.styleOutPath = this.opts.srcPath + 'less/_sprite';
    this.spMap = this.opts.mapPath + 'spmap.json';
    Utils.mkdirsSync(this.imgOutPath);
    Utils.mkdirsSync(this.styleOutPath);
  }


  /**
  * 获取所有雪碧图的源目录
   */

  SpInit.prototype.getSpSrcFolders = function() {
    var _folders;
    _folders = [];
    fs.readdirSync(this.srcPath).forEach(function(file) {
      if (file.indexOf('.') === -1) {
        return _folders.push(file);
      }
    });
    return _folders;
  };


  /**
  * 获取已合成的雪碧图
   */

  SpInit.prototype.getSpPngFiles = function() {
    var _list;
    _list = [];
    fs.readdirSync(this.imgOutPath).forEach(function(v) {
      var name;
      if (v.indexOf('.png') !== -1) {
        name = v.replace('.png', '');
        return _list.push(name);
      }
    });
    return _list;
  };


  /**
  * 获取已生成的雪碧图LESS
   */

  SpInit.prototype.getSpLessFiles = function() {
    var _list;
    _list = [];
    fs.readdirSync(this.styleOutPath).forEach(function(v) {
      var name;
      if (v.indexOf('.less') !== -1) {
        name = v.replace('.less', '');
        return _list.push(name);
      }
    });
    return _list;
  };

  return SpInit;

})();


/**
 * 雪碧图的状态检查类
 */

SpBase = (function(superClass) {
  extend(SpBase, superClass);

  function SpBase() {
    this.getAllNewBuildList = bind(this.getAllNewBuildList, this);
    this.getNewBuildLessFloders = bind(this.getNewBuildLessFloders, this);
    this.getNewBuildPngFolders = bind(this.getNewBuildPngFolders, this);
    return SpBase.__super__.constructor.apply(this, arguments);
  }

  SpBase.prototype.lessIsBuild = function(folder) {
    var _spLess;
    _spLess = path.join(this.outPath, folder + ".less");
    return fs.statSync(_spLess).isFile();
  };

  SpBase.prototype.imgIsBuild = function(folder) {
    var _spImg;
    _spImg = path.join(this.outPath, folder + '.png');
    return fs.statSync(_spImg).isFile();
  };

  SpBase.prototype.getSpMap = function() {
    var _spriteMap;
    if (!_.has(global.Cache, 'spMap')) {
      Utils.getMap('spMap');
    }
    _spriteMap = global.Cache['spMap'];
    return _spriteMap;
  };

  SpBase.prototype.setSpMap = function(cb) {
    var _map, _spFolders, i, key, len;
    this.getSpMap();
    _map = {};
    _spFolders = this.getSpSrcFolders();
    for (i = 0, len = _spFolders.length; i < len; i++) {
      key = _spFolders[i];
      _map[key] = this.getSpSrcList(key);
    }
    Utils.updateMap(_map, 'spMap');
    Utils.saveMapFile('spMap');
    return cb && cb(_map);
  };

  SpBase.prototype.getSpSrcList = function(folder) {
    var _list, _pngsPath;
    _list = [];
    _pngsPath = path.join(this.srcPath, folder);
    fs.readdirSync(_pngsPath).forEach(function(file) {
      var pngFile;
      pngFile = path.join(_pngsPath, file);
      if (file.indexOf('.') !== 0 && file.indexOf('.png') !== -1 && fs.statSync(pngFile)) {
        return _list.push(file);
      }
    });
    return _list;
  };


  /**
  * 返回雪碧图的生成算法 共三个：
  * 默认 binary-tree
  * 目录名的最后包含'_y'，即为Y轴，则为top-down
  * 目录名的最后包含'_x'，即为X轴，则为left-right
   */

  SpBase.prototype.getBuildMethod = function(folder) {
    var method;
    method = (function() {
      switch (false) {
        case !/_x$/.test(folder):
          return 'left-right';
        case !/_y$/.test(folder):
          return 'top-down';
        default:
          return 'binary-tree';
      }
    })();
    return method;
  };


  /**
  * 获取需要生成雪碧图的目录
   */

  SpBase.prototype.getNewBuildPngFolders = function() {
    var _getPngs, _list, _spriteMap, folder_name, i, len, newList, oldList;
    _list = [];
    _spriteMap = this.getSpMap();
    newList = this.getSpSrcFolders();
    oldList = this.getSpPngFiles();
    for (i = 0, len = newList.length; i < len; i++) {
      folder_name = newList[i];
      if (folder_name.indexOf('.') === -1) {
        if (!_spriteMap.hasOwnProperty(folder_name) || indexOf.call(oldList, folder_name) < 0) {
          _list.push(folder_name);
        } else {

          /* 获取当前目录下的所有png文件 */
          _getPngs = this.getSpSrcList(folder_name);
          if (_spriteMap[folder_name].length !== _getPngs.length) {
            _list.push(folder_name);
          }
        }
      }
    }
    return _list;
  };


  /**
  * 获取需要生成LESS的目录
   */

  SpBase.prototype.getNewBuildLessFloders = function() {
    var _list, folder_name, i, len, newList, oldList;
    _list = [];
    newList = this.getSpSrcFolders();
    oldList = this.getSpLessFiles();
    for (i = 0, len = newList.length; i < len; i++) {
      folder_name = newList[i];
      if (indexOf.call(oldList, folder_name) < 0 && folder_name.indexOf('.') === -1) {
        _list.push(folder_name);
      }
    }
    return _list;
  };


  /**
  * 获取需要生成雪碧图和LESS的目录
   */

  SpBase.prototype.getAllNewBuildList = function() {
    var _allFolders, _buildLessFolders, _buildSpPngFolders, _list, file, i, len;
    _buildLessFolders = this.getNewBuildLessFloders();
    _buildSpPngFolders = this.getNewBuildPngFolders();
    _allFolders = _buildLessFolders.concat(_buildSpPngFolders);
    _allFolders = _allFolders.sort();
    _list = [];
    for (i = 0, len = _allFolders.length; i < len; i++) {
      file = _allFolders[i];
      if (indexOf.call(_list, file) < 0) {
        _list.push(file);
      }
    }
    return _list;
  };

  return SpBase;

})(SpInit);

module.exports = SpBase;
