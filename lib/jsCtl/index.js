// Generated by CoffeeScript 1.10.0

/**
 * @fileOverview 将AMD匿名模块转化为具名模块的类库
 * @author pangjg
 * @date 2015年11月26日22:13:31
 * @version $id$
 */
var JsAmdCtl, JsCtl, JsInit, Utils, _, color, fs, gutil, path, plumber, vfs,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

path = require('path');

_ = require('lodash');

vfs = require('vinyl-fs');

plumber = require('gulp-plumber');

gutil = require('gulp-util');

color = gutil.colors;

Utils = require('../utils');

JsInit = require('./jsInit');


/**
 * @fileOverview 将AMD匿名模块转化为具名模块
 * @extends {class} JsInit
 */

JsAmdCtl = (function(superClass) {
  extend(JsAmdCtl, superClass);

  function JsAmdCtl() {
    return JsAmdCtl.__super__.constructor.apply(this, arguments);
  }


  /**
   * [makeAmdMod 将AMD匿名模块转化为具名模块的方法]
   * @param  {String}   files [js源文件路径]
   * @param  {Function} cb    [处理js源文件的过程函数，匿名模块转化为具名模块]
   * @param  {Function} cb2   [全部处理完成后的回调]
   */

  JsAmdCtl.prototype.makeAmdMod = function(files, cb, cb2) {
    var _this;
    _this = this;
    return vfs.src([files]).pipe(plumber({
      errorHandler: Utils.errrHandler
    })).on('data', function(source) {
      var _filePath, _list, _modId, _nameObj, _source;
      _list = [];
      _filePath = source.path.replace(/\\/g, '/').replace(/\/\//g, '/');
      _nameObj = path.parse(_filePath);
      _modId = _this.madeModId(_filePath);
      _source = String(source.contents);
      if (_filePath.split('/js/')[1].indexOf('/') === -1 || _filePath.indexOf("/vendor/") !== -1) {
        return cb(_nameObj, _source);
      } else {
        _source = _source.replace(_this.amdReg, function(str, map) {
          var _arr, _depStr, _str, err, error1;
          _depStr = map.replace(_this.depArrReg, "$1");
          if (/^\[/.test(_depStr)) {
            _arr = _this.tryEval(_depStr);
            try {
              _list = _this.madeModList(_this.filterDepMap(_arr), _nameObj.dir);
              _str = _this.arrToString(_list);
              return str.replace(_this.expStr, "define('" + _modId + "'," + _str + ",function");
            } catch (error1) {
              err = error1;
              return console.log(err);
            }
          } else {
            return str.replace(_this.expStr, "define('" + _modId + "',function");
          }
        });
      }
      return cb(_nameObj, _source);
    }).on('end', cb2);
  };


  /**
   * [toAmd 将所有AMD具名模块写入到调试目录]
   * @param  {String}   file [js的源文件路径，支持模糊路径]
   * @param  {Function} done [构建完成后的回调]
   */

  JsAmdCtl.prototype.toAmd = function(file, done) {
    var _done, _file, _num, _this;
    _this = this;
    gutil.log("Starting", "'" + color.cyan('AMDmodules') + "'...");
    if (typeof file === 'function') {
      _done = file;
      _file = _this.srcPath + '**/*.js';
    } else {
      _file = file || _this.srcPath + '**/*.js';
      _done = done || function() {};
    }
    _num = 0;
    global.Cache['jsSource'] = {};
    return _this.makeAmdMod(_file, function(obj, source) {
      var _dir, _distname;
      _dir = obj.dir.split("/js/")[1];
      _distname = obj.name + obj.ext;
      _dir && (_distname = _dir + '/' + _distname);
      if (_num % 50 === 0 && _num > 15) {
        gutil.log('Building...');
      }
      _file = path.join(_this.debugPath, _distname);
      global.Cache['jsSource'][_distname] = source;
      Utils.writeFile(_file, source, true);
      return _num++;
    }, function() {
      gutil.log("'" + color.cyan('AMDmodules') + "'", "build success.");
      return _done();
    });
  };

  return JsAmdCtl;

})(JsInit);


/**
 * @fileOverview js生产文件构建类库
 * @description 将ADM模块依赖关系和顺序生成生产文件，并进行AMD转化原生模块
 * @extends {class} JsAmdCtl
 */

JsCtl = (function(superClass) {
  extend(JsCtl, superClass);

  function JsCtl() {
    this.allJsDep = bind(this.allJsDep, this);
    this.oneJsDep = bind(this.oneJsDep, this);
    return JsCtl.__super__.constructor.apply(this, arguments);
  }

  JsCtl.prototype.oneJsDep = function(file_path, file_name) {
    var _file;
    _file = path.join(file_path, file_name);
    return this.getOneJsDep(fs.readFileSync(_file, 'utf8').toString());
  };

  JsCtl.prototype.allJsDep = function() {
    var _makeDep, _map, _this;
    _this = this;
    _map = {};
    _makeDep = function(dir) {
      return fs.readdirSync(dir).forEach(function(v) {
        var _fPath, fileDep, name;
        _fPath = path.join(dir, v);
        if (fs.statSync(_fPath).isDirectory() && v !== 'vendor') {
          return _makeDep(_fPath);
        } else if (v === 'vendor') {
          return false;
        } else if (v.indexOf(".js") !== -1) {
          fileDep = _this.oneJsDep(_fPath, '');
          _fPath = Utils.tranFilePath(_fPath);
          name = _fPath.split('/js/')[1].replace(/\.js$/, '');
          return _map["" + name] = fileDep;
        } else {
          return false;
        }
      });
    };
    _makeDep(_this.debugPath);
    return global.Cache['alljsDep'] = _map;
  };

  JsCtl.prototype.makeOneModDeps = function(depsArr) {
    var _alljsDep, _list, _make, _this;
    _this = this;
    _list = [];
    if (!_.has(global.Cache, 'alljsDep')) {
      _this.allJsDep();
    }
    _alljsDep = global.Cache['alljsDep'];
    _make = function(deps) {
      if (_.isArray(deps) && deps.length > 0) {
        return deps.forEach(function(key) {
          var _curDep;
          if (key.indexOf('/') > 0 && _.has(_alljsDep, key)) {
            _curDep = _alljsDep[key];
            _curDep.length > 0 && _make(_curDep);
          }
          return _list.push(key);
        });
      } else {
        if (!_.isArray(deps)) {
          console.log(deps);
        }
      }
    };
    _make(depsArr);
    return _.union(_list);
  };

  JsCtl.prototype.makeAllModDeps = function() {
    var _allDeepDeps, _alljsDep, _commonLibs, _depList, _file, _list, _tempArr, _this, depList, file, i, len;
    _this = this;
    _allDeepDeps = {};
    _commonLibs = [];
    if (!_.has(global.Cache, 'alljsDep')) {
      _this.allJsDep();
    }
    _alljsDep = global.Cache['alljsDep'];
    for (file in _alljsDep) {
      depList = _alljsDep[file];
      _allDeepDeps[file] = {};
      _list = [];
      if (depList.length > 0) {
        _depList = _this.coreModsFilter(depList);
        _tempArr = _this.makeOneModDeps(_depList);
        for (i = 0, len = _tempArr.length; i < len; i++) {
          _file = _tempArr[i];
          if (_file.indexOf("/") !== -1) {
            indexOf.call(_list, _file) < 0 && _list.push(_file);
          } else {
            if (indexOf.call(_commonLibs, _file) < 0) {
              _commonLibs.push(_file);
            }
          }
        }
      }
      _allDeepDeps[file] = _list;
    }
    global.Cache['allDeepDeps'] = _allDeepDeps;
    global.Cache['commonLibs'] = _commonLibs;
    return global.Cache;
  };

  JsCtl.prototype.makeOneModRelateDep = function(modName) {
    if (modName.indexOf("/") === -1 || modName.indexOf('.') === 0) {
      gutil.log("'" + color.red(modName) + "'", "isn't an AMDmodule");
      return [];
    }
    if (!_.has(global.Cache, 'allDeepDeps') || !_.has(global.Cache['allDeepDeps'], modName)) {
      this.makeAllModDeps();
    }
    return global.Cache['allDeepDeps'][modName];
  };

  JsCtl.prototype._amdModBuilder = function(outName, source, cb) {
    var _distPath, _distname, _hash, _jsHash, _outName, _source, _this;
    _this = this;
    _jsHash = {};
    _source = _this.replaceStaticResName(source);
    _source = _this.amdClean(_source);
    _source = Utils.minifyJs(_source);
    _source = [_this.info, _source].join(';');
    _hash = Utils.md5(_source);
    _distname = outName + '.' + _hash.substring(0, _this.hashLen) + ".js";
    _jsHash[outName + ".js"] = {
      hash: _hash,
      distname: _distname
    };
    _distPath = path.join(_this.distPath, _distname);
    _outName = path.join(_this.distPath, outName + ".js");
    gutil.log(_outName, '-->', _distPath);
    if (!fs.existsSync(_distPath)) {
      Utils.writeFile(_distPath, _source, true);
      Utils.writeFile(_outName, _source);
    }
    return cb(_jsHash);
  };


  /* 合并单个模块 */

  JsCtl.prototype.combOneMod = function(name, cb) {
    var _cb, _content, _curFile, _curHash, _curKey, _jsData, _jsFile, _jsHash, _jsMap, _jsSource, _modDeps, _modName, _name, _outName, _source, _tempHash, _this, error, error1, f, i, len;
    _this = this;
    _cb = cb || function() {};
    _modName = name;
    if (!_.has(global.Cache, 'jsMap')) {
      Utils.getMap("jsMap");
    }
    if (!_.has(global.Cache, 'jsHash')) {
      Utils.getMap("jsHash");
    }
    if (!_.has(global.Cache, 'jsSource')) {
      Utils.getMap("jsSource");
    }
    if (_this.opts.force) {
      global.Cache["jsHash"] = {};
    }
    _jsMap = global.Cache['jsMap'];
    _jsHash = global.Cache['jsHash'];
    _jsSource = global.Cache['jsSource'];
    if (_modName.indexOf("_") === 0 || _modName.indexOf("/") === -1 || _modName.indexOf('.') === 0) {
      return _cb(false);
    } else {
      _tempHash = {};
      _jsData = [];
      _modDeps = this.makeOneModRelateDep(_modName);
      _curFile = path.join(this.debugPath, _modName + ".js");
      _outName = this.prefix + "." + _modName.replace(/\//g, '_');
      for (i = 0, len = _modDeps.length; i < len; i++) {
        f = _modDeps[i];
        _jsFile = path.join(this.debugPath, f + ".js");
        _name = f + ".js";
        if (fs.existsSync(_jsFile)) {
          if (_.has(global.Cache['jsSource'], _name)) {
            _source = global.Cache['jsSource'][_name];
          } else {
            _source = fs.readFileSync(_jsFile, 'utf8');
            global.Cache['jsSource'][_name] = _source;
          }
          _jsData.push(_source);
        }
      }
      _jsData.push(fs.readFileSync(_curFile, 'utf8'));
      _content = String(_jsData.join(';'));
      _curHash = Utils.md5(_content);
      _curKey = _outName + ".js";
      _tempHash[_curKey] = _curHash;
      if (_.has(global.Cache['jsHash'], _curKey) && global.Cache['jsHash'][_curKey] === _curHash) {
        gutil.log("'" + color.magenta(_outName) + "'", "no change.");
        return _cb(false);
      } else {
        try {
          Utils.updateMap(_tempHash, 'jsHash');
          return this._amdModBuilder(_outName, _content, function(map) {
            Utils.updateMap(map, 'jsMap');
            return _cb(true);
          });
        } catch (error1) {
          error = error1;
          gutil.log("Error: " + _outName);
          gutil.log(error);
          return _cb(false);
        }
      }
    }
  };


  /* 合并js模块 */

  JsCtl.prototype.combAllMods = function(cb) {
    var _allDeepDeps, _cb, _num, dep, mod;
    _cb = cb || function() {};
    if (!_.has(global.Cache, 'allDeepDeps')) {
      this.makeAllModDeps();
    }
    _allDeepDeps = global.Cache['allDeepDeps'];
    _num = 0;
    gutil.log(color.yellow("Combine AMD modules! Waitting..."));
    for (mod in _allDeepDeps) {
      dep = _allDeepDeps[mod];
      if (mod.indexOf("_") !== 0 && mod.indexOf("/_") === -1 && mod.indexOf('/')) {
        this.combOneMod(mod, function(res) {
          return res && _num++;
        });
      }
    }
    gutil.log(color.magenta("" + _num), "AMD modules changed.");
    gutil.log(color.green("AMD modules Combined..."));
    return _cb();
  };


  /* 合并核心模块 */

  JsCtl.prototype.coreModule = function(cb) {
    var _cb, _commonLibs, _coreMods, _curHash, _curKey, _distName, _distPath, _filePath, _hash, _include, _jsData, _jsHash, _jsLibs, _jsMap, _outName, _outRes, _source, _this, i, key, len;
    _this = this;
    gutil.log("Combine", "'" + color.yellow(" " + _this.coreModsName) + "'", "...");
    _cb = cb || function() {};
    if (!_.has(global.Cache, 'commonLibs')) {
      _this.makeAllModDeps();
    }
    _commonLibs = global.Cache['commonLibs'];
    _distPath = _this.distPath;
    _outName = _this.prefix + '.' + _this.coreModsName;
    _coreMods = _this.coreMods;
    _include = _.union(_coreMods.concat(_commonLibs));
    if (!_.has(global.Cache, 'jsLibs')) {
      Utils.buildReqPaths();
    }
    if (!_.has(global.Cache, 'jsMap')) {
      Utils.getMap("jsMap");
    }
    if (!_.has(global.Cache, 'jsHash')) {
      Utils.getMap("jsHash");
    }
    if (_this.opts.force) {
      global.Cache["jsHash"] = {};
    }
    _jsMap = global.Cache['jsMap'];
    _jsHash = global.Cache['jsHash'];
    _jsLibs = global.Cache['jsLibs'];
    _jsData = [];
    for (i = 0, len = _include.length; i < len; i++) {
      key = _include[i];
      _filePath = _this.debugPath;
      if (_.has(_jsLibs, key)) {
        _filePath += _jsLibs[key] + '.js';
        if (fs.existsSync(_filePath)) {
          _source = fs.readFileSync(_filePath, 'utf8');
          _jsData.push(_source);
        }
      }
    }
    if (_jsData.length === 0) {
      return _cb();
    } else {
      _source = String(_jsData.join(';'));
      _curKey = _outName + ".js";
      _curHash = Utils.md5(_source);
      if (_.has(global.Cache['jsHash'], _curKey) && global.Cache['jsHash'][_curKey] === _curHash) {
        gutil.log("'" + color.magenta(_curKey) + "'", "no change.");
      } else {
        global.Cache['jsHash'][_curKey] = _curHash;
        _source = _this.amdClean(_source);
        _source = Utils.minifyJs(_source);
        _outRes = [_this.info, _outRes].join(';');
        _hash = Utils.md5(_outRes);
        _distName = _outName + '.' + _hash.substring(0, _this.hashLen) + ".js";
        _jsMap[_curKey] = {
          hash: _hash,
          distname: _distName
        };
        if (!fs.existsSync(path.join(_distPath, _distName))) {
          Utils.writeFile(path.join(_distPath, _curKey), _source, !0);
          Utils.writeFile(path.join(_distPath, _distName), _source);
        }
      }
      Utils.updateMap(_jsMap, 'jsMap');
      return _cb();
    }
  };

  JsCtl.prototype.combNormalJs = function(cb) {
    var _cb, _debugPath, _distPath, _jsHash, _jsSource, _tempMap, _this;
    _cb = cb || function() {};
    _this = this;
    _debugPath = this.debugPath;
    _distPath = this.distPath;
    if (!_.has(global.Cache, 'jsSource')) {
      Utils.getMap("jsSource");
    }
    if (!_.has(global.Cache, 'jsMap')) {
      Utils.getMap("jsMap");
    }
    if (!_.has(global.Cache, 'jsHash')) {
      Utils.getMap("jsHash");
    }
    if (_this.opts.force) {
      global.Cache["jsHash"] = {};
    }
    _jsHash = global.Cache['jsHash'];
    _jsSource = global.Cache['jsSource'];
    _tempMap = {};
    fs.readdirSync(_debugPath).forEach(function(v) {
      var _curHash, _distName, _hash, _jsFile, _source;
      _jsFile = path.join(_debugPath, v);
      if (fs.existsSync(_jsFile) && v.indexOf('.js') > 0) {
        if (_.has(_jsSource, v)) {
          _source = _jsSource[v];
        } else {
          _source = fs.readFileSync(_jsFile, 'utf8');
          global.Cache['jsSource'][v] = _source;
        }
        _curHash = Utils.md5(_source);
        if (_.has(global.Cache['jsHash'], v) && global.Cache['jsHash'][v] === _curHash) {
          return gutil.log("'" + color.magenta(v) + "'", "no change.");
        } else {
          global.Cache['jsHash'][v] = _curHash;
          _source = Utils.minifyJs(_source);
          _hash = Utils.md5(_source);
          _distName = v.replace(".js", '') + '.' + _hash.substring(0, _this.hashLen) + ".js";
          _tempMap[v] = {
            hash: _hash,
            distname: _distName
          };
          Utils.writeFile(path.join(_distPath, v), _source);
          if (!fs.existsSync(path.join(_distPath, _distName))) {
            return Utils.writeFile(path.join(_distPath, _distName), _source, true);
          }
        }
      }
    });
    Utils.updateMap(_tempMap, 'jsMap');
    return _cb();
  };

  JsCtl.prototype._saveMap = function() {
    return ['jsHash', 'jsMap', 'allDeepDeps'].forEach(function(key) {
      return Utils.saveMapFile(key);
    });
  };

  JsCtl.prototype.buildAll = function(cb) {
    var _cb, _this;
    _cb = cb || function() {};
    _this = this;
    return _this.coreModule(function() {
      return _this.combAllMods(function() {
        return _this.combNormalJs(function() {
          return _cb();
        });
      });
    });
  };

  JsCtl.prototype.init = function(cb) {
    var _cb, _this;
    _cb = cb || function() {};
    _this = this;
    Utils.getMap("jsMap");
    Utils.getMap("jsHash");
    Utils.buildReqCfg();
    return _this.toAmd(function() {
      Utils.saveMapFile('jsSource');
      if (_this.opts.force) {
        global.Cache["jsHash"] = {};
        return _this.buildAll(function() {
          _this._saveMap();
          return _cb();
        });
      } else if (_this.env !== 'local' && _this.env !== 'dev') {
        return _this.buildAll(function() {
          _this._saveMap();
          return _cb();
        });
      } else {
        if (_this.isDebug && _this.env === 'local') {
          return _this.buildAll(function() {
            return _cb();
          });
        } else {
          return _cb();
        }
      }
    });
  };

  return JsCtl;

})(JsAmdCtl);

module.exports = JsCtl;
